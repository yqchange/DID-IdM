"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCredentialSubject = exports.validateVpType = exports.validateVcType = exports.validateContext = exports.validateTimestamp = exports.validateJwtFormat = void 0;
var constants_1 = require("./constants");
var converters_1 = require("./converters");
function isDateObject(input) {
    return input && Object.prototype.toString.call(input) === '[object Date]' && !isNaN(input);
}
function validateJwtFormat(value) {
    if (typeof value === 'string' && !value.match(constants_1.JWT_FORMAT)) {
        throw new TypeError("\"" + value + "\" is not a valid JWT format");
    }
}
exports.validateJwtFormat = validateJwtFormat;
// The main scenario we want to guard against is having a timestamp in milliseconds
// instead of seconds (ex: from new Date().getTime()).
// We will check the number of digits and assume that any number with 12 or more
// digits is a millisecond timestamp.
// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)
// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)
// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)
function validateTimestamp(value) {
    if (typeof value === 'number') {
        if (!(Number.isInteger(value) && value < 100000000000)) {
            throw new TypeError("\"" + value + "\" is not a unix timestamp in seconds");
        }
    }
    else if (typeof value === 'string') {
        validateTimestamp(Math.floor(new Date(value).valueOf() / 1000));
    }
    else if (!isDateObject(value)) {
        throw new TypeError("\"" + value + "\" is not a valid time");
    }
}
exports.validateTimestamp = validateTimestamp;
function validateContext(value) {
    var input = converters_1.asArray(value);
    if (input.length < 1 || input.indexOf(constants_1.DEFAULT_CONTEXT) === -1) {
        throw new TypeError("@context is missing default context \"" + constants_1.DEFAULT_CONTEXT + "\"");
    }
}
exports.validateContext = validateContext;
function validateVcType(value) {
    var input = converters_1.asArray(value);
    if (input.length < 1 || input.indexOf(constants_1.DEFAULT_VC_TYPE) === -1) {
        throw new TypeError("type is missing default \"" + constants_1.DEFAULT_VC_TYPE + "\"");
    }
}
exports.validateVcType = validateVcType;
function validateVpType(value) {
    var input = converters_1.asArray(value);
    if (input.length < 1 || input.indexOf(constants_1.DEFAULT_VP_TYPE) === -1) {
        throw new TypeError("type is missing default \"" + constants_1.DEFAULT_VP_TYPE + "\"");
    }
}
exports.validateVpType = validateVpType;
function validateCredentialSubject(value) {
    if (Object.keys(value).length === 0) {
        throw new TypeError('credentialSubject must not be empty');
    }
}
exports.validateCredentialSubject = validateCredentialSubject;
//# sourceMappingURL=validators.js.map