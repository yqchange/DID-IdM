import{ec as e}from"elliptic";import{SimpleSigner as r,toEthereumAddress as t,createJWT as i,verifyJWT as s}from"did-jwt";export{SimpleSigner}from"did-jwt";import{createVerifiableCredentialJwt as n,verifyPresentation as a}from"did-jwt-vc";import o from"ethr-did-resolver";import{getResolver as c}from"web-did-resolver";import{Resolver as l}from"did-resolver";import{isMNID as d,decode as u}from"mnid";var p,h;!function(e){e.Function="function",e.Event="event",e.Constructor="constructor",e.Fallback="fallback"}(p||(p={})),function(e){e.Pure="pure",e.View="view",e.NonPayable="nonpayable",e.Payable="payable"}(h||(h={}));const f=e=>{const r=["from","to","data","value","gasPrice","gas"];if("object"!=typeof e)return!1;if(0===Object.keys(e).length)return!0;for(const t of r)if(t in e)return!0;return!1},E=(e,r)=>{let t=e.name+"(";const i=e.inputs||[];for(let e=0;e<i.length;e++){const s=i[e];let n=s.type+" ";n+="string"===s.type?`"${r[e]}"`:""+r[e],t+=n,i.length-1!==e&&(t+=", ")}return t+")"},y=e=>r=>({at:t=>{const i={};return(e=>e.filter(e=>e.type===p.Function&&e.name&&!e.constant))(r).forEach(r=>{r.name&&(i[r.name]=function(){let i={};const s=[].slice.call(arguments),n=(r.inputs||[]).length;f(s[n])&&(i=s.splice(n,1)[0]);const a={...i,to:t,function:E(r,s)};if(!e)return a;const o=s[s.length-1];return e(a,o)})}),{...i,abi:r,address:t}}}),g=new e("secp256k1");var v;!function(e){e.DISCLOSURE_REQUEST="shareReq",e.DISCLOSURE_RESPONSE="shareResp",e.TYPED_DATA_SIGNATURE_REQUEST="eip712Req",e.VERIFICATION_SIGNATURE_REQUEST="verReq",e.ETH_TX_REQUEST="ethtx",e.PERSONAL_SIGN_REQUEST="personalSigReq",e.PRESENTATION_REQUEST="presentationReq"}(v||(v={}));class m{constructor({did:e,address:i,privateKey:s,signer:n,ethrConfig:a,resolver:u}){if(n?this.signer=n:s&&(this.signer=r(s)),e)this.did=e;else if(i)d(i)&&(this.did="did:uport:"+i),i.match("^0x[0-9a-fA-F]{40}$")&&(this.did="did:ethr:"+i);else if(s){const e=g.keyFromPrivate(s),r=t(e.getPublic("hex"));this.did="did:ethr:"+r}if(u)this.resolver=u;else{const e=o.getResolver(a||{}),r=c();this.resolver=new l({...r,...e,https:r.web})}}static createIdentity(){const e=g.genKeyPair(),r=e.getPublic("hex"),i=e.getPrivate("hex");return{did:"did:ethr:"+t(r),privateKey:i}}signJWT(e,r){return this.did&&this.signer?i(e,{issuer:this.did,signer:this.signer,alg:this.did.match("^did:uport:")||d(this.did)?"ES256K":"ES256K-R",expiresIn:r}):Promise.reject(new Error("No Signing Identity configured"))}createDisclosureRequest(e={},r=600){const t={};if(e.requested&&(t.requested=e.requested),e.verified&&(t.verified=e.verified),e.claims&&(t.claims=e.claims),e.notifications&&(t.permissions=["notifications"]),e.callbackUrl&&(t.callback=e.callbackUrl),e.networkId&&(t.net=e.networkId),e.rpcUrl){if(!e.networkId)return Promise.reject(new Error("rpcUrl was specified but no networkId"));t.rpc=e.rpcUrl}if(e.vc&&(t.vc=e.vc),e.exp&&(t.exp=e.exp),e.accountType){if(!(["general","segregated","keypair","none"].indexOf(e.accountType)>=0))return Promise.reject(new Error("Unsupported accountType "+e.accountType));t.act=e.accountType}return e.boxPub&&(t.boxPub=e.boxPub),this.signJWT({...t,type:v.DISCLOSURE_REQUEST},e.exp?void 0:r)}createVerification({sub:e,claim:r,exp:t,vc:i,callbackUrl:s}){return this.signJWT({sub:e,claim:r,exp:t,vc:i,callbackUrl:s})}createVerificationSignatureRequest(e,{aud:r,sub:t,riss:i,callbackUrl:s,vc:n,rexp:a,expiresIn:o}){return this.signJWT({unsignedClaim:e,sub:t,riss:i,aud:r,vc:n,callback:s,type:v.VERIFICATION_SIGNATURE_REQUEST,rexp:a},o)}async createTypedDataSignatureRequest(e,{from:r,net:t,callback:i}={}){for(const r of["types","primaryType","message","domain"])if(!e[r])throw new Error(`Invalid EIP712 Request, must include '${r}'`);return await this.signJWT({typedData:e,from:r,net:t,callback:i,type:v.TYPED_DATA_SIGNATURE_REQUEST})}createPersonalSignRequest(e,{from:r,net:t,callback:i}={}){return this.signJWT({data:e,from:r,net:t,callback:i,type:v.PERSONAL_SIGN_REQUEST})}createTxRequest(e,{callbackUrl:r,exp:t=600,networkId:i,label:s}={}){const n={};return r&&(n.callback=r),i&&(n.net=i),s&&(n.label=s),this.signJWT({...n,...e,type:v.ETH_TX_REQUEST},t)}async createDisclosureResponse(e={},r=600){if(e.req){const r=await s(e.req,{resolver:this.resolver});r.issuer&&(e.aud=r.issuer)}return this.signJWT({...e,type:v.DISCLOSURE_RESPONSE},r)}async processDisclosurePayload({doc:e,payload:r}){const{own:t={},capabilities:i=[],nad:n,dad:a,iss:o,boxPub:c,verified:l,...d}=r,{uportProfile:p={}}=e,h={did:o,boxPub:c,...t,...p,...d};if(a&&(h.deviceKey=a),n&&(h.mnid=n,h.address=u(n).address),1===i.length&&(h.pushToken=i[0]),l){const e=[],r=l.map(r=>s(r,{resolver:this.resolver,audience:this.did}).catch(()=>(e.push(r),Promise.resolve(void 0)))),t=await Promise.all(r),i=[];t.forEach(e=>{e&&i.push({...e.payload,jwt:e.jwt})}),h.verified=i,h.invalid=e}return h}async authenticateDisclosureResponse(e,r){const{payload:t,doc:i}=await s(e,{resolver:this.resolver,audience:this.did,callbackUrl:r,auth:!0});if(t.req){const e=(await s(t.req,{resolver:this.resolver,audience:this.did})).payload;if(e.type!==v.DISCLOSURE_REQUEST)throw new Error("Challenge payload type invalid: "+e.type);return this.processDisclosurePayload({payload:t,doc:i})}throw new Error("Challenge was not included in response")}async verifyDisclosure(e){const{payload:r,doc:t}=await s(e,{resolver:this.resolver,audience:this.did});return this.processDisclosurePayload({payload:r,doc:t})}async issueVerifiableCredential(e){if(!this.did||!this.signer)return Promise.reject(new Error("No Signing Identity configured"));const r={did:this.did,signer:this.signer};return await n(e,r)}async verifyPresentation(e){return await a(e,this.resolver)}contract(e){return y(((e,r)=>(e.function&&(e.fn=e.function),delete e.function,this.createTxRequest(e,r))).bind(this))(e)}}export{y as ContractFactory,m as Credentials};
//# sourceMappingURL=index.modern.js.map
